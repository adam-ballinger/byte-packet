/**
 * @fileoverview `byte-packet` is a lightweight utility module designed for generating, 
 * manipulating, and validating byte packets with cryptographic security in Node.js or the browser.
 * It integrates payload generation, checksum calculation, and flexible byte array handling. 
 * Emphasis on performance, minimalism, and ease of integration.
 * 
 * https://github.com/adam-ballinger/byte-packet#readme
 * 
 * @module byte-packet
 * @author Adam Ballinger
 * @version 1.0.0
 * @license MIT
 * @date 2024-08-29
 */

const sha256 = require('js-sha256');
const randomBytes = require('randombytes');
const bs58 = require('bs58').default;

/**
 * Generates a byte packet from the specified payload, checksum size, and flag.
 * 
 * This function creates a packet by first calculating a checksum based on the 
 * provided payload and checksum size. It then generates a header containing the 
 * checksum size and flag information. Finally, it combines the header, payload, 
 * and checksum into a single `Uint8Array`.
 *
 * @param {Uint8Array} payload - The data to be included in the packet.
 * @param {number} [checksumSize=1] - The size of the checksum in bytes. Default is 1 byte.
 * @param {number} [flag=0] - A flag used in the header for additional packet information. Default is 0.
 * @returns {Uint8Array} The generated byte packet as a `Uint8Array`.
 */
function generatePacket(payload, checksumSize=1, flag=0) {
    const checksum = calculateChecksum(payload, checksumSize);
    const header = generateHeader(checksumSize, flag);

    return combineUint8Arrays([header, payload, checksum]);
}


/**
 * Generates a random Uint8Array payload of the specified size.
 * 
 * @param {number} size - The size of the Uint8Array to generate.
 * @returns {Uint8Array} A Uint8Array filled with cryptographically secure random values.
 */
function generateRandomPayload(size) {
    // Fill the array with cryptographically secure random values
    let randomBuffer = randomBytes(size);
    return new Uint8Array(randomBuffer)
}

/**
 * Checks if two Uint8Arrays are equal in length and content.
 * 
 * @param {Uint8Array} arr1 - The first Uint8Array to compare.
 * @param {Uint8Array} arr2 - The second Uint8Array to compare.
 * @returns {boolean} True if the Uint8Arrays are equal, false otherwise.
 */
function Uint8ArraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }

    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }

    return true;
}

/**
 * Calculates a checksum from a given input payload.
 * 
 * @param {Uint8Array} payload - The input payload for which to calculate the checksum.
 * @param {number} size - The size of the checksum to generate.
 * @returns {Uint8Array} A Uint8Array containing the checksum derived from the payload.
 */
function calculateChecksum(payload, size) {
    // Create SHA-256 hash of the payload
    const hash = sha256.array(payload);

    // Return the first n bytes of the hash as the checksum, according to the size parameter
    return new Uint8Array(hash.slice(0, size));
}

/**
 * Checks the validity of a payload and its associated checksum.
 * 
 * @param {Uint8Array} payload - The payload to validate.
 * @param {Uint8Array} checksum - The checksum to validate against.
 * @returns {boolean} True if the checksum is valid for the given payload, false otherwise.
 */
function checkPair(payload, checksum) {

    // Assume checksum provided is the correct size
    let size = checksum.length;

    const calculatedChecksum = calculateChecksum(payload, size);

    return Uint8ArraysEqual(checksum, calculatedChecksum);   
}

/**
 * Combines a list of Uint8Arrays into a single Uint8Array.
 * 
 * @param {Uint8Array[]} arrays - An array of Uint8Array instances to be combined.
 * @returns {Uint8Array} A single Uint8Array containing all the concatenated data.
 */
function combineUint8Arrays(arrays) {

  // Calculate the total length of the combined array
  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);

  // Create a new Uint8Array with the total length
  const combinedArray = new Uint8Array(totalLength);

  // Copy each array into the combined array
  let offset = 0;
  for (const arr of arrays) {
    // Ensure offset is within bounds and copy data
    if (offset + arr.length > combinedArray.length) {
      throw new RangeError('Offset is out of bounds for the combined array.');
    }

    combinedArray.set(arr, offset);
    offset += arr.length;
  }

  return combinedArray;
}

/**
 * Splits a byte packet into its header, payload, and checksum components.
 * 
 * @param {Uint8Array} packet - The byte packet to split.
 * @returns {Object} An object containing the header, payload, and checksum.
 */
function splitPacket(packet) {

    let header = packet.slice(0, 1);
    let checksumSize = getChecksumSize(header);
    let flag = getFlag(header);
    let payloadSize = packet.length - 1 - checksumSize;

    let payload = packet.slice(1, 1+payloadSize);
    let checksum = packet.slice(1+payloadSize, 1+payloadSize+checksumSize);

    return {header, payload, checksum, checksumSize, flag};
}

/**
 * Gets info about the packet.
 * 
 * @param {Uint8Array} packet - The byte packet to split.
 * @returns {Object} An object containing the checksumSize, flag, payloadSize, and validity.
 */
function info(packet) {

    let header = packet.slice(0, 1);
    let checksumSize = getChecksumSize(header);
    let flag = getFlag(header);
    let payloadSize = packet.length - 1 - checksumSize;
    let isValid = checkPacket(packet);

    return {checksumSize, flag, payloadSize, isValid};
}

/**
 * Checks the validity of a byte packet by validating its payload and checksum.
 * 
 * @param {Uint8Array} packet - The byte packet to check.
 * @returns {boolean} True if the packet is valid, false otherwise.
 */
function checkPacket(packet) {
    let {payload, checksum} = splitPacket(packet);
    return checkPair(payload, checksum);
}

/**
 * Generates a random byte packet with a specified payload size, checksum size, and header flag.
 * 
 * @param {number} payloadSize - The size of the payload to generate.
 * @param {number} checksumSize - The size of the checksum to generate.
 * @param {number} flag - A flag value to include in the packet header.
 * @returns {Uint8Array} A Uint8Array representing the generated byte packet.
 */
function generateRandomPacket(payloadSize, checksumSize, flag) {
    const payload = generateRandomPayload(payloadSize);
    const checksum = calculateChecksum(payload, checksumSize);
    const header = generateHeader(checksumSize, flag);

    return combineUint8Arrays([header, payload, checksum]);
}

/**
 * Generates a 1-byte header as a Uint8Array.
 * 
 * @param {number} checksumSize - A 3-bit value (0-7) representing the checksum size.
 * @param {number} flag - A 5-bit value (0-31) representing flags to be used by consumers.
 * @returns {Uint8Array} A Uint8Array containing the 1-byte header.
 */
function generateHeader(checksumSize, flag) {
    
    // Validate input ranges
    if (checksumSize < 0 || checksumSize > 7) throw new Error("Checksum size must be a 3-bit value (0-7).");
    if (flag < 0 || flag > 31) throw new Error("Type must be a 3-bit value (0-7).");

    // Pack the values into a single byte
    const headerByte = (checksumSize << 5) | (flag);
  
    // Create a Uint8Array with the packed header
    return new Uint8Array([headerByte]);
}

/**
 * Extracts the checksum size from a 1-byte header.
 * 
 * @param {Uint8Array} header - A Uint8Array containing the 1-byte header.
 * @returns {number} The extracted checksum size (a 3-bit value between 0 and 7).
 */
function getChecksumSize(header) {
    if (header.length !== 1) throw new Error("Header must be a 1-byte Uint8Array.");

    // Extract the first 3 bits for the checksum size
    const checksumSize = (header[0] >> 5) & 0b00000111; // Shift right 5 bits and mask the lower 3 bits

    return checksumSize;
}

/**
 * Extracts the 5-bit flag from a 1-byte header Uint8Array.
 * 
 * @param {Uint8Array} header - A Uint8Array containing the 1-byte header.
 * @returns {number} The extracted 5-bit flag as an integer (0-31).
 * @throws {Error} If the header is not a 1-byte Uint8Array.
 */
function getFlag(header) {
    if (header.length !== 1) {
        throw new Error("Header must be a 1-byte Uint8Array.");
    }

    // Extract the lower 5 bits by masking with 0b00011111 (or 0x1F in hexadecimal)
    const flag = header[0] & 0b00011111;

    return flag;
}

/**
 * Converts a byte packet (Uint8Array) to a Base58-encoded string.
 * 
 * @param {Uint8Array} packet - The byte packet to be encoded.
 * @returns {string} The Base58-encoded string representing the byte packet.
 */
function encodeBase58(packet) {
    return bs58.encode(packet);
}

/**
 * Decodes a Base58-encoded string back into a byte packet (Uint8Array).
 * 
 * This function decodes a Base58 string into a Uint8Array and checks if the resulting
 * byte packet is valid. If the packet is valid, it returns the decoded byte packet.
 * If the packet is not valid, it throws an error.
 * 
 * @param {string} base58 - The Base58-encoded string to be decoded.
 * @returns {Uint8Array} The decoded byte packet (Uint8Array) if valid.
 * @throws {Error} If the decoded packet is not a valid byte packet.
 */
function decodeBase58(base58) {
    let decodedPacket = bs58.decode(base58);

    let isValid = checkPacket(decodedPacket);

    if(isValid) {
        return decodedPacket;
    } else {
        throw new Error(`The decoded packet is not a valid byte packet.\n${decodedPacket}`);
    }    
}


// Exports
module.exports = {
    generatePacket,
    generateRandomPayload,
    Uint8ArraysEqual,
    calculateChecksum,
    checkPair,
    combineUint8Arrays,
    splitPacket,
    info,
    checkPacket,
    generateRandomPacket,
    encodeBase58,
    decodeBase58
}